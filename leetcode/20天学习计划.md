
# [20 天学习计划](https://leetcode-cn.com/study-plan/algorithms/?progress=vtoj0tm)

## day 1 二分查找
[704 二分查找](https://leetcode-cn.com/problems/binary-search/)

注意事项：
- while(left <= right)
- mid = Math.floor((right - left) / 2) + left 
```ts
function search(nums: number[], target: number): number {
    let left = 0
    let right = nums.length -1
    while(left <= right) {
        // let mid = Math.floor( (right + left) / 2)
        let mid = Math.floor((right - left) / 2) + left // 防止栈溢出, 防止 left + right 溢出
        if(nums[mid] === target) {
             return mid
        } else if(target > nums[mid]) {
            left = mid + 1
        } else {
            right = mid - 1;
        }
    }
    return -1;
}
```

[278 第一个错误版本](https://leetcode-cn.com/problems/first-bad-version/)

```ts
var solution = function(isBadVersion: any) {
    return function(n: number): number {
        let left = 0
        let right = n - 1 // 索引要减1
        while(left <= right) {
            let mid = Math.floor((right - left) / 2) + left
            if(isBadVersion(mid)) {
                right = mid - 1
            } else {
                left = mid + 1
            }
        }
        return left // 此时区间缩为一个点
    };
};
```

[35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

标准二分查找

```ts

function searchInsert(nums: number[], target: number): number {
    let left = 0
    let right = nums.length - 1
    while(left <= right) {
        let mid = Math.floor((right - left) / 2) + left
        if(nums[mid] == target) {
            return mid
        } else if(nums[mid] < target) {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return left
}
```

## day2 双指针

[977. 有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)

- 分析题目，有序数组平方后最大值在两端，所以在两端遍历数组
- 使用 `push` 互逆的方法 `shift` 向数组的开头添加元素

```ts
function sortedSquares(nums: number[]): number[] {
    let l = 0, r = nums.length - 1
    const resArr = []
    while(l <= r) {
        if(nums[l] ** 2 >= nums[r] ** 2) {
            resArr.unshift(nums[l] ** 2)
            l++
        } else {
            resArr.unshift(nums[r] ** 2)
            r--
        }
    }
    return resArr
}
```
[53. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)

- 使用动态规划，若前一个数大于0，则将其加到当前元素
- 然后取数组中的最大值
```ts
// 若前一个数大于0，则将其加到当前元素上，最后取数组的最大值
function maxSubArray(nums: number[]): number {
    for(let i = 0; i < nums.length - 1; i++) {
        if(nums[i] > 0) {
            nums[i + 1] += nums[i]
        }
    }
    return Math.max(...nums)
};
```

## day3 双指针

[283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

```ts
function moveZeroes(nums: number[]): void {
    let zeroCount = 0 // 记录0的个数
    let j = 0 // 移动后 nums 索引
    let i = 0 // 原 nums 索引
    // 将不为0的数放到数组的头部
    for(let i = 0; i < nums.length; i++) {
        if(nums[i] !== 0) {
            nums[j++] = nums[i]
        }
    }
    // 用0填充剩余部分
    for(let k = j; k < nums.length; k++) {
        nums[k] = 0
    }
};
```

[167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/submissions/)
- 充分利用已排序这个特性，看来排序很重要，排完序一切都变得 easy 了
- 从数组两端查找 target 对应的下标
```ts
function twoSum(numbers: number[], target: number): number[] {
    let l = 0, r = numbers.length - 1
    while(l < r) {
        const res = numbers[l] + numbers[r]
        if(res > target) {
            // 结果太大，移动右边指针
            r--
        } else if(res < target) {
            // 结果小，移动左边指针
            l++
        } else {
            // 下标从1开始，给l和r各加1
            return [l+1, r+1]
        }
    }
};
```

[88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)
- 要考虑 i === m 和 j === n 的情况

方法1
```ts
function merge(nums1: number[], m: number, nums2: number[], n: number): void {
    const sortedArr = Array(m+n).fill(0)
    let i = 0, j = 0
    while(i < m || j < n) {
        if(i === m) {
            sortedArr[i + j] = nums2[j++]
        } else if(j === n) {
            sortedArr[i + j] = nums1[i++]
        } else if(nums1[i] <= nums2[j]) {
            sortedArr[i + j] = nums1[i++]
        } else {
            sortedArr[i + j] = nums2[j++]
        }
    }
    for(let i = 0; i < nums1.length; i++) {
        nums1[i] = sortedArr[i]
    }
};
```

方法2
- 充分发挥艰苦奋斗的精神，利用好 `nums1` 自身空间
- 考虑边界条件，当 m=0 或 n = 0时要特殊处理
```ts
function merge(nums1: number[], m: number, nums2: number[], n: number): void {
    // 从后往前遍历
    let p1 = m - 1, p2 = n - 1
    let len = m + n - 1
    while(p1 >= 0 || p2 >= 0) {
        // nums1[len--] = nums1[p1] >= nums2[p2] ? nums1[p1--] : nums2[p2--]
        // 考虑 m 或 n 为 0 的情况
        if(p1 === -1) {
            // 从后往前取最大值
            nums1[len--] = nums2[p2--]
        } else if(p2 === -1) {
            nums1[len--] = nums1[p1--]
        } else if(nums1[p1] >= nums2[p2]) {
            nums1[len--] = nums1[p1--]
        } else {
            nums1[len--] = nums2[p2--]
        }
    }
}
```

## day4 双指针
- 双指针 yyds

[344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)
```ts
function reverseString(s: string[]): void {
    // 交换数字首尾字符
    let l = 0, r = s.length - 1
    let t = ''
    while(l < r) {
        let t = s[r]
        s[r--] = s[l]
        s[l++] = t
    }
}
```
[557. 反转字符串中的单词 III](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/solution/)
```ts
function reverseWords(s: string): string {
    const sArr = s.split(' ')
    for(let i = 0; i < sArr.length; i++) {
        // js 中 string 为不可变类型，先用此方法吧
        sArr[i] = sArr[i].split('').reverse().join('')
    }
    return sArr.join(' ')
};
```

[350. 两个数组的交集 II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)
```ts
function intersect(nums1: number[], nums2: number[]): number[] {
    const intersetNum = []
    nums1.forEach(item => {
        if(nums2.includes(item)) {
            const nums2Idx = nums2.findIndex(i => i === item)
            nums2.splice(nums2Idx, 1)
        // 删除nums2中这个元素，如果下次还出现的话再 push 到intersetNum 中
            intersetNum.push(item)
        }
    })
    return intersetNum
};
```

## day 5 双指针

[876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)

思路：
- 优化，使用双指针法, `fast` 一次走2步， `slow` 一次走1步

```ts
class ListNode {
  constructor(val, next) {
    this.val = val === undefined ? 0 : val
    this.next = next === undefined ? null : next
  }
}

function middleNode(head: ListNode | null): ListNode | null {
    // 计算链表长度
    let len = 0
    let ansIndex = 0
    let cur:ListNode = head
    while(cur !== null) {
        cur = cur.next
        len++
    }
    cur = head
    ansIndex = Math.floor(len / 2)
    while(ansIndex > 0) {
        cur = cur.next
        ansIndex--
    }
    return cur
};

function middleNode2(head) {
  let slow = fast = head
  while(fast && fast.next) {
    slow = slow.next
    fast = fast.next.next
  }
  return slow
}

```
[19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

方法一 朴素法
```ts
function removeNthFromEnd(head: ListNode | null, n: number): ListNode | null {
    const dummyNode = new ListNode(0, head)
    let len = 0
    let cur = dummyNode
    while(cur !== null) {
        len++
        cur = cur.next
    }
    let count = len - n - 1 // 链表需要走的次数
    cur = dummyNode
    while(count > 0) {
        console.log(count, 'count')
        cur = cur.next
        count--
    }
    cur.next = cur.next.next
    return dummyNode.next
};
```
方法二 快慢指针法
```js
var removeNthFromEnd = function(head, n) {
    // 不用判断 head 是否为空了  
    const dummyNode = new ListNode(0, head)
    let slow = fast = dummyNode
    //  先让快指针走 n 步
    for(let i = 0; i < n; i++) {
        fast = fast.next
    }
    while(fast && fast.next !== null) {
        fast = fast.next
        slow = slow.next
    }
    slow.next = slow.next.next
    return dummyNode.next
}
```

## day 6 滑动窗口

[3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

依然使用双指针，根据条件扩大或缩小窗口
```ts
function lengthOfLongestSubstring(s: string): number {
    let max = 0
    const strWindow = new Set()
    let l = 0, r = 0
    while(r < s.length) {
        if(!strWindow.has(s[r])) { // 窗口扩大
            max = Math.max(max, r - l + 1)
            strWindow.add(s[r++])
        } else { // 窗口减小
            strWindow.delete(s[l++])
        }
    }
    return max
};
```

## day 7 广度优先搜索 / 深度优先搜索

- 写好递归的退出条件
- 搜索时与顺序无关

[695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

```ts
function dfs(grid:number[][], i:number, j:number):number {
    const row = grid.length
    const col = grid[0].length
    if(i < 0 || j < 0 || i === row || j === col || grid[i][j] !== 1) {
        return 0
    }
    let ans = 1
    grid[i][j] = 0
    ans += dfs(grid, i, j - 1)
    ans += dfs(grid, i, j + 1)
    ans += dfs(grid, i - 1, j)
    ans += dfs(grid, i + 1, j)
    return ans
}

function maxAreaOfIsland(grid: number[][]): number {
    let max = 0
    for(let i = 0; i < grid.length; i++) {
        for(let j = 0; j < grid[0].length; j++) {
            max = Math.max(max, dfs(grid, i, j))
        }
    }
    return max
};
```

## day8 广度优先搜索 / 深度优先搜索
[617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)
- 遍历树即可

```ts
function mergeTrees(root1: TreeNode | null, root2: TreeNode | null): TreeNode | null {
    if(root1 === null) {
        return root2
    }
    if(root2 === null) {
        return root1
    }
    const merged = new TreeNode(root1.val + root2.val)
    merged.left = mergeTrees(root1.left, root2.left)
    merged.right = mergeTrees(root1.right, root2.right)
    return merged
}
```
